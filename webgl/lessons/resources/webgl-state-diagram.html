<!-- 

idea:

Show some webgl code. Let user step through, show 
updates to state.  lLiI1

-->
<link href="/3rdparty/monokai-sublime.css" rel="stylesheet">
<style>
body {
  margin: 0;
}
.svg-center {
  text-anchor: middle;
  dominant-baseline: central;
  fill: red;
}
.box {
  stroke-width: 1px;
  stroke: black;
}
*[data-help]:hover {
  outline: 1px solid red;
  cursor: pointer;
}
.draggable {
  position: absolute;
  box-shadow: 2px 2px 15px #000;
}
#arrows {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 999;
  pointer-events: none;
}
#hint {
  position: absolute;
  display: inline-block;
  pointer-events: none;
  background: #444;
  color: white;
  border: 1px solid black;
  box-shadow: 5px 5px 10px black;
  padding: 1em;
  max-width: 600px;
  font-family: Arial, Helvetica, sans-serif;
  z-index: 1000;
}
#hint a {
  color: aquamarine;
}
html {
  box-sizing: border-box;
}
*, *::before, *::after {
  box-sizing: inherit;
}
body {
  font-family: monospace;
}
.name {
  font-weight: bold;
  text-align: center;
  padding-bottom: 5px;
}
.state-block {
  border: 1px solid black;
  background: hsl(240, 100%, 85%);
  display: inline-block;
}
.title,
.webgl-object {
  border: 1px solid black;
  display: inline-block;
  padding: 10px;
}
#global-state { background: hsl(0, 100%, 85%); }
.texture { background: hsl(200, 100%, 85%); }
.vertex-array { background: hsl(260, 100%, 85%); }
.shader { background: hsl(30, 100%, 80%); }
.program { background: hsl(30, 100%, 70%); }
.program-attributes { background: hsl(30, 100%, 80%); }
.program-uniforms { background: hsl(30, 100%, 80%); }
.program-attributes, .program-uniforms {
  margin-top: 10px;
  border: 1px solid black;
}
/* .vertex-array .attrib-enabled {  } */
.vertex-array .attrib-disabled { background: #888; }
.shader {
  display: flex;
  flex-direction: column;
}
.shader>*:last-child {
  flex: 1 1 auto;
  background: #23241f
}
.expander.open>div:first-child {
  margin-bottom: 10px;
}
.expander>div:first-child::before {
  content: '▶';
}
.expander>*:nth-child(0n+2) {
  display: none;
}
.expander {
  padding: 0 0.5em 0 0.5em;
}
.expander.open {
  background: rgba(255, 255, 255, 0.3);
  padding: 0.5em;
  /* animation: flash 1s 1; */
}
.expander.open>*:nth-child(0n+2) {
  display: unset;
}
.expander.open>div:first-child:before {
  content: '▼';
}

@keyframes flash {
  1% {
    background-color: red;
  }
}
    


table {
  border-collapse: collapse;
  display: block;
}
td, th {
  border: 1px solid black;
  padding: 0.25em;
}
th {
  background: rgba(255,255,255,0.3);
}
.across2 {
  display: flex;
}
.across2>*:first-child {
  margin-right: 5px;
}
.across2>*:last-child {
  margin-left: 5px;
}
.fill-height {
  align-items: stretch;
}
.mips {
  display: flex;
  align-items: flex-end;
}
.mips>* {
  border: 1px solid black;
  margin-right: 2px;
  background: hsl(0, 100%, 50%);
  background-size: cover;
}
.mip0 {
  width: 128px;
  height: 128px;
}
.mip1 {
  width: 64px;
  height: 64px;
}
.mip2 {
  width: 32px;
  height: 32px;
}
.mip3 {
  width: 16px;
  height: 16px;
}
.mip4 {
  width: 8px;
  height: 8px;
}
.mip5 {
  width: 4px;
  height: 4px;
}
.mip6 {
  width: 2px;
  height: 2px;
}
.mip7 {
  width: 1px;
  height: 1px;
}
#everything {
  display: flex;
}
#diagram {
  flex: 3 1 auto;
  width: 70%;
  user-select: none;
}
#code {
  flex: 1 1 auto;
  overflow: scroll;
  background: #444;
  color: white;
  width: 30%;
  max-height: 100vh;
}
#code pre {
  margin: 0;
}
</style>
<body>
<div id="everything">
  <div id="diagram">
    <canvas></canvas>
    <div id="global-state">
      <div class="title">global state</div>
    </div>

    <svg id="arrows" width="100%" height="100%">
      <defs>
        <marker id="arrowhead" viewBox="0 0 10 10" refX="3" refY="5"
            markerWidth="6" markerHeight="6" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" />
        </marker>
      </defs>
      <g fill="none" stroke="black" stroke-width="2" marker-end="url(#arrowhead)">
        <path id="arrowLeft"/>
        <path id="arrowRight"/>
      </g>  
    </svg>
  </div>
  <div id="code"></div>
</div>
<div id="hint"></div>

<template id="texture-template">
<div class="webgl-object texture" data-help="
Textures are created with

```js
const tex = gl.createTexture();
```

and bound to a texture unit bind point (target) with

```
gl.activeTexture(gl.TEXTURE0 + texUnitIndex);
const bindPoint = gl.TEXTURE_2D;
gl.bindTexture(bindPoint, tex);
```

All texture functions reference textures
through the bind points on the active texture unit.
ie.

```js
texture = textureUnits[activeTexture][bindPoint]
```
">
  <div class="name">Texture</div>
  <div class="mips"></div>
</div>
</template>

<template id="vertex-attributes-template">
      <table>
        <thead><th>enabled</th><th>value</th><th>size</th><th>type</th><th>normalize</th><th>stride</th><th>offset</th><th>buffer</th><th>divisor</th></thead>
        <tbody>
        </tbody>
      </table>
</template>

<template id="vertex-array-template">
  <div class="webgl-object vertex-array" data-help="
Normally there is only the 1 default vertex array in WebGL 1.0.

You can create more vertex arrays with the
[`OES_vertex_array_object`](https://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object/)
extension.

```js
const ext = gl.getExtension('OES_vertex_array_object')
const vertexArray = ext.createVertexArrayOES();
```

and bind one (make it the current vertex array) with

```js
ext.bindVertexArrayOES(someVertexArray);
```

Passing `null` to `gl.bindVertexArrayOES` binds the default vertex array.
">
    <div class="name">vertex array</div>
    <div class="state-table">
    </div>
  </div>
</template>

<template id="vertex-shader-template">
  <div>
    <div class="webgl-object shader vertex-shader" data-help="
A vertex shader's sole responsibility is to set `gl_Position`
to a clip space position. To create one use:

```js
const shader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(shader, glslString);
gl.compileShader(shader);
if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === 0) {
  console.error(gl.getShaderInfoLog(shader));
}
```
">
      <pre><code class="lang-glsl"></code></pre>
    </div>
  </div>
</template>

<template id="fragment-shader-template">
  <div>
    <div class="webgl-object shader fragment-shader" data-help="
A fragment shader's sole responsibility is to set `gl_FragColor`
to a color. To create one use:

```js
≈const shader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(shader, glslString);
gl.compileShader(shader);
if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === 0) {
  console.error(gl.getShaderInfoLog(shader));
}
```
">
      <pre><code class="lang-glsl"></code></pre>
    </div>
  </div>
</template>

<template id="program-template">
  <div class="webgl-object program" data-help="
A program is a combination of a vertex shader
and a fragment shader *linked* together.

```js
const program = gl.createProgram();
gl.attachShader(program, someVertexShader);
gl.attachShader(program, someFragmentShader);
gl.linkProgram(program);
if (gl.getProgramParameter(program, gl.LINK_STATUS) === 0) {
  console.error(gl.getProgramInfoLog(program));
}
```
">
    <div class="name">program</div>
  </div>
</template>

</body>
<script src="/3rdparty/showdown.min.js"></script>
<script src="/3rdparty/highlight.pack.js"></script>
<script src="../../resources/m4.js"></script>
<script id="js" type="not-js">
'use strict';

const vs = `
attribute vec4 position;
attribute vec3 normal;
attribute vec2 texcoord;

uniform mat4 projection;
uniform mat4 modelView;

varying vec3 v_normal;
varying vec2 v_texcoord;

void main() {
    gl_Position = projection * modelView * position;
    v_normal = mat3(modelView) * normal;
    v_texcoord = texcoord;
}
`;

const fs = `
precision highp float;

varying vec3 v_normal;
varying vec2 v_texcoord;

uniform sampler2D diffuse;
uniform vec3 lightDir;

void main() {
    vec3 normal = normalize(v_normal);
    float light = dot(normal, lightDir) * 0.5 + 0.5;
    vec4 color = texture2D(diffuse, v_texcoord);
    gl_FragColor = vec4(color.rgb * light, color.a);
}
`;

const cubeVertexPositions = new Float32Array([1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1]);
const cubeVertexNormals   = new Float32Array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);
const cubeVertexTexcoords = new Float32Array([1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1]);
const cubeVertexIndices   = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],);

const gl = document.querySelector('canvas').getContext('webgl');
const prg = createProgram(gl, vs, fs);

const positionLoc = gl.getAttribLocation(prg, 'position');
const normalLoc = gl.getAttribLocation(prg, 'normal');
const texcoordLoc = gl.getAttribLocation(prg, 'texcoord');

const projectionLoc = gl.getUniformLocation(prg, 'projection');
const modelViewLoc = gl.getUniformLocation(prg, 'modelView');
const diffuseLoc = gl.getUniformLocation(prg, 'diffuse');
const lightDirLoc = gl.getUniformLocation(prg, 'lightDir');

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, cubeVertexPositions, gl.STATIC_DRAW);

const normalBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
gl.bufferData(gl.ARRAY_BUFFER, cubeVertexNormals, gl.STATIC_DRAW);

const texcoordBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
gl.bufferData(gl.ARRAY_BUFFER, cubeVertexTexcoords, gl.STATIC_DRAW);

const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndices, gl.STATIC_DRAW);

const checkerTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, checkerTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,                // mip level
    gl.LUMINANCE,     // internal format
    4,                // width
    4,                // height
    0,                // border
    gl.LUMINANCE,     // format
    gl.UNSIGNED_BYTE, // type
    new Uint8Array([  // data
      192, 128, 192, 128,
      128, 192, 128, 192,
      192, 128, 192, 128,
      128, 192, 128, 192,
    ]));
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

gl.clearColor(0.5, 0.7, 1.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);

gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
gl.enableVertexAttribArray(normalLoc);
gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);

gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
gl.enableVertexAttribArray(texcoordLoc);
gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 0, 0);

gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

gl.useProgram(prg);

const texUnit = 3;
gl.activeTexture(gl.TEXTURE0 + texUnit);
gl.bindTexture(gl.TEXTURE_2D, checkerTexture);
gl.uniform1i(diffuseLoc, texUnit);

gl.uniform3fv(lightDirLoc, m4.normalize([1, 5, 3]));

const projection = m4.perspective(
  60 * Math.PI / 180,  // fov
  gl.canvas.clientWidth / gl.canvas.clientHeight,  // aspect
  0.1,  // near
  10,   // far
);
gl.uniformMatrix4fv(projectionLoc, false, projection);

let modelView = m4.identity();
modelView = m4.translate(modelView, 0, 0, -4);
modelView = m4.xRotate(modelView, 0.5);
modelView = m4.yRotate(modelView, 0.5);

gl.uniformMatrix4fv(modelViewLoc, false, modelView);

gl.drawElements(
    gl.TRIANGLES,
    36,                // num vertices to process
    gl.UNSIGNED_SHORT, // type of indices
    0,                 // offset on bytes to indices
);
</script>
<script>
/* eslint strict: "off" */
//'use strict';

hljs.initHighlightingOnLoad();

const styleToText = styles => Object.entries(styles).map(([key, value]) => `${key}:${value};`).join('');
const hsl = (h, s, l) => `hsl(${h * 360},${s * 100 | 0}%,${l * 100 | 0}%)`;
const px = (v) => `${v}px`;

function helpToMarkdown(s) {
  s = s.replace(/---/g, '```')
       .replace(/--/g, '`');
  const m = /^\n( +)/.exec(s);
  if (!m) {
    return s;
  }
  const lines = s.split('\n');
  if (lines[0].trim() === '') {
    lines.shift();
  }
  if (lines[lines.length - 1].trim() === '') {
    lines.pop();
  }
  const indent = m[1];
  return lines.map(line => line.startsWith(indent) ? line.substr(indent.length) : line).join('\n');
}

const converter = new showdown.Converter();
const hintElem = document.querySelector('#hint');
let lastWidth;
let lastHint;
function setHint(e, hint = '') {
  if (lastHint !== hint) {
    lastHint = hint;
    const html = converter.makeHtml(hint);
    hintElem.innerHTML = html;
    hintElem.querySelectorAll('pre>code').forEach(elem => hljs.highlightBlock(elem));
    lastWidth = hintElem.clientWidth;
  }
  hintElem.style.left = px(e.pageX + lastWidth > window.innerWidth ? window.innerWidth - lastWidth : e.pageX + 5);
  hintElem.style.top = px(e.pageY + 5);
  hintElem.style.display = hint ? '' : 'none';
}

document.body.addEventListener('mousemove', function(e) {
  let elem = e.target;
  while (!elem.dataset.help && elem.nodeName !== 'BODY') {
      elem = elem.parentElement;
  }
  setHint(e, elem.dataset.help);
});

const webglFuncs = `
--gl.NEVER--,
--gl.LESS--,
--gl.EQUAL--,
--gl.LEQUAL--,
--gl.GREATER--,
--gl.NOTEQUAL--,
--gl.GEQUAL--,
--gl.ALWAYS--
`;

const depthState = [
  {
    pname: 'DEPTH_TEST',
    value: 'TRUE',
    help: `
      to enable

      ---js
      gl.enable(gl.DEPTH_TEST);
      ---

      to disable

      ---js
      gl.disable(gl.DEPTH_TEST);
      ---
    `,
  },
  {
    pname: 'DEPTH_FUNC',
    value: 'LESS',
    help: `
      ---js
      gl.depthFunc(func);
      ---

      sets the function used for the depth test where func is one of
      ${webglFuncs}.
    `,
  },
  {
    pname: 'DEPTH_RANGE',
    value: '0, 1',
    help: `
      specifies how to convert from clip space to a depth value

      ---js
      gl.depthRange(zNear, zFar);
      ---
    `,
  },
  {
    pname: 'DEPTH_WRITEMASK',
    value: 'true',
    help: `
      sets whether or not to write to the depth buffer

      ---js
      gl.depthMask(trueFalse);
      ---
    `,
  },
];

function addElem(tag, parent, attrs = {}) {
  const elem = document.createElement(tag);
  for (const [key, value] of Object.entries(attrs)) {
    if (typeof value === 'object') {
      for (const [k, v] of Object.entries(value)) {
        try {
        elem[key][k] = v;
        } catch (e) {
          debugger;  // eslint-disable-line no-debugger
        }
      }
    } else if (elem[key] === undefined) {
      elem.setAttribute(key, value);
    } else {
      elem[key] = value;
    }
  }
  parent.appendChild(elem);
  return elem;
}

let dragTarget;
let dragMouseStartX;
let dragMouseStartY;
let dragTargetStartX;
let dragTargetStartY;

function toggleExpander(e) {
  e.preventDefault();
  e.stopPropagation();
  e.target.parentElement.classList.toggle('open');
}

function dragStart(e) {
  e.preventDefault();
  e.stopPropagation();
  dragTarget = this;
  const rect = this.getBoundingClientRect();
  dragMouseStartX = e.pageX;
  dragMouseStartY = e.pageY;
  dragTargetStartX = (window.scrollX + rect.left) | 0; // parseInt(this.style.left || '0');
  dragTargetStartY = (window.scrollY + rect.top) | 0;  // parseInt(this.style.top || '0');

  window.addEventListener('mousemove', dragMove, {passive: false});
  window.addEventListener('mouseup', dragStop, {passive: false});

  const elements = [];
  document.querySelectorAll('.draggable').forEach(elem => {
    if (elem !== this) {
      elements.push(elem);
    }
  });
  elements.sort((a, b) => a.style.zIndex > b.style.zIndex);
  elements.push(this);
  elements.forEach((elem, ndx) => {
    elem.style.zIndex = ndx + 1;
  });
}

function dragMove(e) {
  if (dragTarget) {
    e.preventDefault();
    e.stopPropagation();
    const x = dragTargetStartX + (e.pageX - dragMouseStartX);
    const y = dragTargetStartY + (e.pageY - dragMouseStartY);
    dragTarget.style.left = px(x);
    dragTarget.style.top = px(y);
    drawConnector();
  }
}

function dragStop(e) {
  e.preventDefault();
  e.stopPropagation();
  dragTarget = undefined;
  window.removeEventListener('mousemove', dragMove);
  window.removeEventListener('mouseup', dragStop);
}

function makeDraggable(elem, x = 0, y = 0) {
  const div = addElem('div', elem.parentElement, {
    className: 'draggable',
    style: {
      left: px(x),
      top: px(y),
    },
  });
  elem.parentElement.removeChild(elem);
  div.appendChild(elem);
  div.addEventListener('mousedown', dragStart, {passive: false});
}

function createExpander(parent, title, attrs = {}) {
  const outer = addElem('div', parent, Object.assign({className: 'expander'}, attrs));
  const titleElem = addElem('div', outer, {
    textContent: title,
  });
  titleElem.addEventListener('click', toggleExpander);
  titleElem.addEventListener('mousedown', (e) => e.stopPropagation());
  return outer;
}

function createStateTable(states, parent, title) {
  const expander = createExpander(parent, title);
  const table = addElem('table', expander);
  const tbody = addElem('tbody', table);
  for (const state of states) {
    const {pname, value, help} = state;
    const tr = addElem('tr', tbody);
    tr.dataset.help = helpToMarkdown(help);
    addElem('td', tr, {textContent: pname});
    addElem('td', tr, {textContent: value});
  }
  return expander;
}

function isBuiltIn(info) {
  const name = info.name;
  return name.startsWith("gl_") || name.startsWith("webgl_");
}

function createProgramAttributes(parent, gl, program) {
  const tbody = createTable(parent, ['name', 'location']);

  const numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let ii = 0; ii < numAttribs; ++ii) {
    const attribInfo = gl.getActiveAttrib(program, ii);
    if (isBuiltIn(attribInfo)) {
        continue;
    }
    const index = gl.getAttribLocation(program, attribInfo.name);
    const tr = addElem('tr', tbody);
    const help = helpToMarkdown(`
      get attribute location with

      ---js
      const loc = gl.getAttribLocation(program, '${attribInfo.name}');
      ---
      
      attribute locations are chosen by WebGL. You can choose locations
      by calling.

      ---js
      gl.bindAttribLocation(program, desiredLocation, '${attribInfo.name}');
      ---

      **BEFORE** calling
      
      ---js
      gl.linkProgram(program);
      ---
    `);
    addElem('td', tr, {textContent: attribInfo.name, dataset: {help}});
    addElem('td', tr, {textContent: index, dataset: {help}});
  }
}

const getUniformInfo = (function() {

const FLOAT                         = 0x1406;
const FLOAT_VEC2                    = 0x8B50;
const FLOAT_VEC3                    = 0x8B51;
const FLOAT_VEC4                    = 0x8B52;
const INT                           = 0x1404;
const INT_VEC2                      = 0x8B53;
const INT_VEC3                      = 0x8B54;
const INT_VEC4                      = 0x8B55;
const BOOL                          = 0x8B56;
const BOOL_VEC2                     = 0x8B57;
const BOOL_VEC3                     = 0x8B58;
const BOOL_VEC4                     = 0x8B59;
const FLOAT_MAT2                    = 0x8B5A;
const FLOAT_MAT3                    = 0x8B5B;
const FLOAT_MAT4                    = 0x8B5C;
const SAMPLER_2D                    = 0x8B5E;
const SAMPLER_CUBE                  = 0x8B60;
const SAMPLER_3D                    = 0x8B5F;
const SAMPLER_2D_SHADOW             = 0x8B62;
const FLOAT_MAT2x3                  = 0x8B65;
const FLOAT_MAT2x4                  = 0x8B66;
const FLOAT_MAT3x2                  = 0x8B67;
const FLOAT_MAT3x4                  = 0x8B68;
const FLOAT_MAT4x2                  = 0x8B69;
const FLOAT_MAT4x3                  = 0x8B6A;
const SAMPLER_2D_ARRAY              = 0x8DC1;
const SAMPLER_2D_ARRAY_SHADOW       = 0x8DC4;
const SAMPLER_CUBE_SHADOW           = 0x8DC5;
const UNSIGNED_INT                  = 0x1405;
const UNSIGNED_INT_VEC2             = 0x8DC6;
const UNSIGNED_INT_VEC3             = 0x8DC7;
const UNSIGNED_INT_VEC4             = 0x8DC8;
const INT_SAMPLER_2D                = 0x8DCA;
const INT_SAMPLER_3D                = 0x8DCB;
const INT_SAMPLER_CUBE              = 0x8DCC;
const INT_SAMPLER_2D_ARRAY          = 0x8DCF;
const UNSIGNED_INT_SAMPLER_2D       = 0x8DD2;
const UNSIGNED_INT_SAMPLER_3D       = 0x8DD3;
const UNSIGNED_INT_SAMPLER_CUBE     = 0x8DD4;
const UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;

const TEXTURE_2D                    = 0x0DE1;
const TEXTURE_CUBE_MAP              = 0x8513;
const TEXTURE_3D                    = 0x806F;
const TEXTURE_2D_ARRAY              = 0x8C1A;

const typeMap = {};

/**
 * Returns the corresponding bind point for a given sampler type
 */
function getBindPointForSamplerType(gl, type) {
  return typeMap[type].bindPoint;
}

// This kind of sucks! If you could compose functions as in `var fn = gl[name];`
// this code could be a lot smaller but that is sadly really slow (T_T)

const floatSetter = 'gl.uniform1f(location, value);';
const floatArraySetter = 'gl.uniform1fv(location, arrayOfValues);';
const floatVec2Setter = 'gl.uniform2fv(location, arrayOf2Values); // or\ngl.uniform2f(location, v0, v1);';
const floatVec3Setter = 'gl.uniform3fv(location, arrayOf3Values); // or\ngl.uniform3f(location, v0, v1, v2);';
const floatVec4Setter = 'gl.uniform4fv(location, arrayOf4Values); // or\ngl.uniform4f(location, v0, v1, v2, v3);';
const intSetter = 'gl.uniform1i(location, value);';
const intArraySetter = 'gl.uniform1iv(location, arrayOfValues);';
const intVec2Setter = 'gl.uniform2iv(location, arrayOf2Values); // or\ngl.uniform2i(location, v0, v1)';
const intVec3Setter = 'gl.uniform3iv(location, arrayOf3Values); // or\ngl.uniform3i(location, v0, v1, v2)';
const intVec4Setter = 'gl.uniform4iv(location, arrayOf4Values); // or\ngl.uniform4i(location, v0, v1, v2, v3)';
const uintSetter = 'gl.uniform1ui(location, value);';
const uintArraySetter = 'gl.uniform1uiv(location, arrayOf1Value);';
const uintVec2Setter = 'gl.uniform2uiv(location, arrayOf2Values); // or\ngl.uniform2ui(location, v0, v1)';
const uintVec3Setter = 'gl.uniform3uiv(location, arrayOf3Values); // or\ngl.uniform3ui(location, v0, v1, v2)';
const uintVec4Setter = 'gl.uniform4uiv(location, arrayOf4Values); // or\ngl.uniform4ui(location, v0, v1, v2, v3)';
const floatMat2Setter = 'gl.uniformMatrix2fv(location, false, arrayOf4Values);';
const floatMat3Setter = 'gl.uniformMatrix3fv(location, false, arrayOf9Values);';
const floatMat4Setter = 'gl.uniformMatrix4fv(location, false, arrayOf16Values);';
const floatMat23Setter = 'gl.uniformMatrix2x3fv(location, false, arrayOf6Values);';
const floatMat32Setter = 'gl.uniformMatrix3x2fv(location, false, arrayOf6values);';
const floatMat24Setter = 'gl.uniformMatrix2x4fv(location, false, arrayOf8Values);';
const floatMat42Setter = 'gl.uniformMatrix4x2fv(location, false, arrayOf8Values);';
const floatMat34Setter = 'gl.uniformMatrix3x4fv(location, false, arrayOf12Values);';
const floatMat43Setter = 'gl.uniformMatrix4x3fv(location, false, arrayOf12Values);';
const samplerSetter = 'gl.uniform1i(location, textureUnitIndex);\n// note: this only tells the shader\n// which texture unit to reference.\n// you still need to bind a texture\n// to that texture unit';
const samplerArraySetter = 'gl.uniform1iv(location, arrayOfTextureUnitIndices);';

typeMap[FLOAT]                         = { Type: Float32Array, size:  4, setter: floatSetter,      arraySetter: floatArraySetter, };
typeMap[FLOAT_VEC2]                    = { Type: Float32Array, size:  8, setter: floatVec2Setter,  };
typeMap[FLOAT_VEC3]                    = { Type: Float32Array, size: 12, setter: floatVec3Setter,  };
typeMap[FLOAT_VEC4]                    = { Type: Float32Array, size: 16, setter: floatVec4Setter,  };
typeMap[INT]                           = { Type: Int32Array,   size:  4, setter: intSetter,        arraySetter: intArraySetter, };
typeMap[INT_VEC2]                      = { Type: Int32Array,   size:  8, setter: intVec2Setter,    };
typeMap[INT_VEC3]                      = { Type: Int32Array,   size: 12, setter: intVec3Setter,    };
typeMap[INT_VEC4]                      = { Type: Int32Array,   size: 16, setter: intVec4Setter,    };
typeMap[UNSIGNED_INT]                  = { Type: Uint32Array,  size:  4, setter: uintSetter,       arraySetter: uintArraySetter, };
typeMap[UNSIGNED_INT_VEC2]             = { Type: Uint32Array,  size:  8, setter: uintVec2Setter,   };
typeMap[UNSIGNED_INT_VEC3]             = { Type: Uint32Array,  size: 12, setter: uintVec3Setter,   };
typeMap[UNSIGNED_INT_VEC4]             = { Type: Uint32Array,  size: 16, setter: uintVec4Setter,   };
typeMap[BOOL]                          = { Type: Uint32Array,  size:  4, setter: intSetter,        arraySetter: intArraySetter, };
typeMap[BOOL_VEC2]                     = { Type: Uint32Array,  size:  8, setter: intVec2Setter,    };
typeMap[BOOL_VEC3]                     = { Type: Uint32Array,  size: 12, setter: intVec3Setter,    };
typeMap[BOOL_VEC4]                     = { Type: Uint32Array,  size: 16, setter: intVec4Setter,    };
typeMap[FLOAT_MAT2]                    = { Type: Float32Array, size: 16, setter: floatMat2Setter,  };
typeMap[FLOAT_MAT3]                    = { Type: Float32Array, size: 36, setter: floatMat3Setter,  };
typeMap[FLOAT_MAT4]                    = { Type: Float32Array, size: 64, setter: floatMat4Setter,  };
typeMap[FLOAT_MAT2x3]                  = { Type: Float32Array, size: 24, setter: floatMat23Setter, };
typeMap[FLOAT_MAT2x4]                  = { Type: Float32Array, size: 32, setter: floatMat24Setter, };
typeMap[FLOAT_MAT3x2]                  = { Type: Float32Array, size: 24, setter: floatMat32Setter, };
typeMap[FLOAT_MAT3x4]                  = { Type: Float32Array, size: 48, setter: floatMat34Setter, };
typeMap[FLOAT_MAT4x2]                  = { Type: Float32Array, size: 32, setter: floatMat42Setter, };
typeMap[FLOAT_MAT4x3]                  = { Type: Float32Array, size: 48, setter: floatMat43Setter, };
typeMap[SAMPLER_2D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };
typeMap[SAMPLER_CUBE]                  = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };
typeMap[SAMPLER_3D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };
typeMap[SAMPLER_2D_SHADOW]             = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };
typeMap[SAMPLER_2D_ARRAY]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };
typeMap[SAMPLER_2D_ARRAY_SHADOW]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };
typeMap[SAMPLER_CUBE_SHADOW]           = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };
typeMap[INT_SAMPLER_2D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };
typeMap[INT_SAMPLER_3D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };
typeMap[INT_SAMPLER_CUBE]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };
typeMap[INT_SAMPLER_2D_ARRAY]          = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };
typeMap[UNSIGNED_INT_SAMPLER_2D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };
typeMap[UNSIGNED_INT_SAMPLER_3D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };
typeMap[UNSIGNED_INT_SAMPLER_CUBE]     = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };
typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };

return function(type) {
  return typeMap[type];
};

}());

function createTable(parent, headings) {
  const table = addElem('table', parent);
  const thead = addElem('thead', table);
  headings.forEach(heading => addElem('th', thead, {textContent: heading}));
  return addElem('tbody', table);
}

function formatUniformValue(v) {
  if (v.buffer && v.buffer instanceof ArrayBuffer) {
    v = Array.from(v);
  }
  if (Array.isArray(v)) {
    if (v.length === 16) {
      const s = [];
      v.forEach((v, ndx) => {
        s.push(`${v.toFixed(3)}${ndx !== v.length - 1 ? ',' : ''}${ndx % 4 === 3 ? '\n' : ''}`);
      });
      return s.join('');
    }
    return v.map(v => v.toFixed(3)).join(', ');
  }
  return typeof v === 'number' ? v.toFixed(3) : v;
}

function createProgramUniforms(parent, gl, program) {
  const tbody = createTable(parent, ['name', 'loc', 'value']);
  const uniformSetters = { };
  const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

  for (let ii = 0; ii < numUniforms; ++ii) {
    const uniformInfo = gl.getActiveUniform(program, ii);
    if (isBuiltIn(uniformInfo)) {
        continue;
    }
    let name = uniformInfo.name;
    // remove the array suffix.
    if (name.substr(-3) === "[0]") {
      name = name.substr(0, name.length - 3);
    }
    const loc = gl.getUniformLocation(program, name);
    const info = getUniformInfo(uniformInfo.type);
    const help = helpToMarkdown(`---js\ngl.useProgram(program); // set current program\n${info.setter}\n---`);

    const tr = addElem('tr', tbody);
    addElem('td', tr, {textContent: name, dataset: {help}});
    addElem('td', tr, {
      textContent: '?',
      dataset: {
        help: helpToMarkdown(`---js\nconst loc = gl.getUniformLocation(program, '${name}');\n---`),
      },
    });
    addElem('td', tr, {
      textContent: formatUniformValue(gl.getUniform(program, loc)),
      dataset: {help},
    });
  }
}

function createShaderDisplay(parent, type, glsl) {
  const expander = createExpander(parent, `${type} shader`);
  createTemplate(expander, `#${type}-shader-template`);
  expander.querySelector('.lang-glsl').textContent = glsl;
}

function createProgramDisplay(parent, gl, program) {
  const prgElem = createTemplate(parent, '#program-template');

  const shaders = gl.getAttachedShaders(program);

  // sort so VERTEX_SHADER is first.
  shaders.sort((a, b) => {
    const aType = gl.getShaderParameter(a, gl.SHADER_TYPE);
    const bType = gl.getShaderParameter(b, gl.SHADER_TYPE);
    return aType < bType;
  });

  const types = ['vertex', 'fragment'];
  types.forEach((type, ndx) => {
    createShaderDisplay(prgElem, type, gl.getShaderSource(shaders[ndx]));
  });

  const attribExpander = createExpander(prgElem, 'attribute info', {
    dataset: {
      hint: 'attributes are user defined. Their values come from buffers as specified in a *vertex array*.',
    },
  });
  const uniformExpander = createExpander(prgElem, 'uniforms', {
    dataset: {
      hint: 'uniform values are user defined program state. The locations and values are different for each program.',
    },
  });

  createProgramAttributes(attribExpander, gl, prg);
  createProgramUniforms(uniformExpander, gl, prg);

  expand(attribExpander);
  expand(uniformExpander);

  makeDraggable(prgElem);
  return prgElem;
}

function createTemplate(parent, selector) {
  const template = document.querySelector(selector);
  const collection = template.content.cloneNode(true);
  if (collection.children.length !== 1) {
    throw new Error('template must have 1 child');
  }
  const elem = collection.children[0];
  parent.appendChild(elem);
  return elem;
}

function createVertexArrayDisplay(parent, attribs = [], maxAttribs = 8) {
  const vaElem = createTemplate(parent, '#vertex-array-template');
  const vaoNote = helpToMarkdown(`
    note: the current vertex array can be set with the
    [--OES_vertex_array_object--](https://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object/)
    extension. Otherwise there is only the 1 default vertex array in WebGL 1.0.
  `);
  const attrExpander = createExpander(vaElem.querySelector('.state-table'), 'attributes');
  const table = createTemplate(attrExpander, '#vertex-attributes-template');
  const attrsElem = table.querySelector('tbody');

  for (let i = 0; i < maxAttribs; ++i) {
    const {size = 1, type = 'FLOAT', normalize = 'false', stride = '0', offset = '0', buffer = 'null', divisor = '0'} = attribs[i] || {};
    const enabled = i < attribs.length;
    const enabledClassName = enabled ? 'attrib-enabled' : 'attrib-disabled';
    const disabledClassName = enabled ? 'attrib-disabled' : 'attrib-enabled';
    const tr = addElem('tr', attrsElem);
    addElem('td', tr, {
      textContent: enabled,
      dataset: {
        help: helpToMarkdown(`
        * --true-- this attribute uses data from a buffer.
        * --false-- it uses --value--.

        ---js
        const index = gl.getAttribLocation(program, 'someAttrib'); // ${i}
        gl.enableVertexAttribArray(index);   // turn on
        gl.disableVertexAttribArray(index);  // turn off
        ---

        ${vaoNote}`),
      },
    });
    addElem('td', tr, {
      textContent: '0,0,0,1',
      className: disabledClassName,
      dataset: {
        help: helpToMarkdown(`
        The value used if this attribute is disabled.

        ---js
        const index = gl.getAttribLocation(program, 'someAttrib'); // ${i}
        gl.vertexAttrib4fv(index, [1, 2, 3, 4]);
        ---

        ${vaoNote}`),
      },
    });
    addElem('td', tr, {
      textContent: size,
      className: enabledClassName,
      dataset: {
        help: helpToMarkdown(`
        Number of values to pull from buffer per vertex shader iteration

        ---js
        const index = gl.getAttribLocation(program, 'someAttrib'); // ${i}
        gl.vertexAttribPointer(index, SIZE, type, normalize, stride, offset);
        ---

        ${vaoNote}`),
      },
    });
    addElem('td', tr, {
      textContent: type,
      className: enabledClassName,
      dataset: {
        help: helpToMarkdown(`
        The type of the data to read from the buffer. 
        --BYTE--, --UNSIGNED_BYTE--, --SHORT--, --UNSIGNED_SHORT--,
        --INT--, --UNSIGNED_INT--, --FLOAT--

        ---js
        const index = gl.getAttribLocation(program, 'someAttrib'); // ${i}
        gl.vertexAttribPointer(index, size, TYPE, normalize, stride, offset);
        ---

        ${vaoNote}`),
      },
    });
    addElem('td', tr, {
      textContent: normalize,
      className: enabledClassName,
      dataset: {
        help: helpToMarkdown(`
        true = use the value as is
        false = convert the value to 0.0 to 1.0 for UNSIGNED types
        and -1.0 to 1.0 for signed types.

        ---js
        const index = gl.getAttribLocation(program, 'someAttrib'); // ${i}
        gl.vertexAttribPointer(index, size, type, NORMALIZE, stride, offset);
        ---

        ${vaoNote}`),
      },
    });
    addElem('td', tr, {
      textContent: stride,
      className: enabledClassName,
      dataset: {
        help: helpToMarkdown(`
        how many bytes to advance in the buffer per vertex shader iteration
        to get to the next value for this attribute. 0 is a special value
        that means WebGL will figure out the stride from the --type-- and
        --size-- arguments.
        
        ---js
        const index = gl.getAttribLocation(program, 'someAttrib'); // ${i}
        gl.vertexAttribPointer(index, size, type, normalize, STRIDE, offset);
        ---

        ${vaoNote}`),
      },
    });
    addElem('td', tr, {
      textContent: offset,
      className: enabledClassName,
      dataset: {
        help: helpToMarkdown(`
        The offset in bytes where the data for this attribute starts in the buffer.
        
        ---js
        const index = gl.getAttribLocation(program, 'someAttrib'); // ${i}
        gl.vertexAttribPointer(index, size, type, normalize, stride, OFFSET);
        ---

        ${vaoNote}`),
      },
    });
    addElem('td', tr, {
      textContent: buffer,
      className: enabledClassName,
      dataset: {
        help: helpToMarkdown(`
        The buffer this attribute will pull data from. This gets set
        implicitly when calling --gl.vertexAttribPointer-- from the
        currently bound --ARRAY_BUFFER--
        
        ---js
        const index = gl.getAttribLocation(program, 'someAttrib'); // ${i}

        // bind someBuffer to ARRAY_BUFFER
        gl.bindBuffer(gl.ARRAY_BUFFER, someBuffer);

        // someBuffer will get bound to this attribute
        gl.vertexAttribPointer(index, size, type, normalize, stride, offset);
        ---

        ${vaoNote}`),
      },
    });
    addElem('td', tr, {
      textContent: divisor,
      className: enabledClassName,
      dataset: {
        help: helpToMarkdown(`
        Used with the [ANGLE_instanced_arrays extension](https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays/).
        If --divisor-- === 0 then this attribute advances normally, once each vertex shader iteration.
        If --divisor-- > 0 then this attribute advances once each --divisor-- instances.
        
        ---js
        const ext = gl.getExtension('ANGLE_instanced_arrays');
        const index = gl.getAttribLocation(program, 'someAttrib'); // ${i}
        ext.vertexAttribDivisor(index, divisor);
        ---

        ${vaoNote}`),
      },
    });
  }

  const vaState = [
    {
      pname: 'ELEMENT_ARRAY_BUFFER',
      value: 'null',
      help: `
      buffer that contains element indices used when calling --gl.drawElements--.

      ---js
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, someBuffer);
      ---
      `,
    },
  ];
  createStateTable(vaState, vaElem.querySelector('.state-table'), 'state');
  makeDraggable(vaElem);
  return vaElem;
}

const stencilOps = helpToMarkdown(`--KEEP--, --ZERO--, --REPLACE--, --INCR--, --INCR_WRAP--, --DECR--, --DECR_WRAP--, --INVERT--`);
const stencilFuncSnippet = face => helpToMarkdown(`
---js
const func = gl.ALWAYS;
const ref = 0x1;
const mask = 0xFF;

// set for both front and back facing triangles
gl.stencilFunc(func, ref, mask);

// set only for ${face} facing triangles
const face = gl.${face.toUpperCase()};
gl.stencilFuncSeparate(face, func, ref, mask);
---
`);

const stencilOpSnippet = face => helpToMarkdown(`
---js
const stencilFailOp = gl.KEEP;
const depthFailOp = gl.KEEP;
const depthPassUp = gl.INCR;

// sets for both front and back facing triangles
gl.stencilOp(stencilFailOp, depthFailOp, depthPassUp); 

// set only for ${face} facing triangles
const face = gl.${face.toUpperCase()};
gl.stencilOpSeparate(face, stencilFailOp, depthFailOp, depthPassUp);
---
`);

const stencilWriteMaskSnippet = face => `
write mask for stencil for ${face} facing triangles.

---js
const mask = 0xFF;

// set for both front and back facing triangles
gl.stencilMask(mask);

// set only for ${face} facing triangles.
const face = gl.${face.toUpperCase()};
gl.stencilMaskSeparate(face, mask);
---
`;

const stencilState = [
    {
      pname: 'STENCIL_TEST',
      value: 'false',
      help: `
      Stencil test enabled/disabled

      ---js
      gl.enable(gl.STENCIL_TEST);
      gl.disable(gl.STENCIL_TEST);
      ---
      `,
    },
    {
      pname: 'STENCIL_FUNC',
      value: 'ALWAYS',
      help: `
      function to use for stencil test for front facing triangles.
      One of ${webglFuncs}.

${stencilFuncSnippet('front')}
      `,
    },
    {
      pname: 'STENCIL_FAIL',
      value: 'KEEP',
      help: `
      operation when stencil test fails for front facing triangles.
      One of: ${stencilOps}

${stencilOpSnippet('front')}
      `,
    },
    {
      pname: 'STENCIL_PASS_DEPTH_FAIL',
      value: 'KEEP',
      help: `
      operation when depth test fails for front facing triangles.
      One of: ${stencilOps}

${stencilOpSnippet('front')}
      `,
    },
    {
      pname: 'STENCIL_PASS_DEPTH_PASS',
      value: 'KEEP',
      help: `
      operation when depth test passes for front facing triangles.
      One of: ${stencilOps}

${stencilOpSnippet('front')}
      `,
    },
    {
      pname: 'STENCIL_REF',
      value: '0',
      help: `
      reference value to use for stencil test for front facing triangles.

${stencilFuncSnippet('front')}
      `,
    },
    {
      pname: 'STENCIL_VALUE_MASK',
      value: '',
      help: `
      mask value to use for stencil test for front facing triangles.

${stencilFuncSnippet('front')}
      `,
    },
    {
      pname: 'STENCIL_WRITEMASK',
      value: '0xFF',
      help: stencilWriteMaskSnippet('front'),
    },
    {
      pname: 'STENCIL_BACK_FUNC',
      value: 'ALWAYS',
      help: `
      function to use for stencil test for back facing triangles.
      One of ${webglFuncs}.

${stencilFuncSnippet('back')}
      `,
    },
    {
      pname: 'STENCIL_BACK_FAIL',
      value: 'KEEP',
      help: `
      operation when stencil test fails for back facing triangles.
      One of: ${stencilOps}

${stencilOpSnippet('back')}
      `,
    },
    {
      pname: 'STENCIL_BACK_PASS_DEPTH_FAIL',
      value: 'KEEP',
      help: `
      operation when depth test fails for back facing triangles.
      One of: ${stencilOps}

${stencilOpSnippet('back')}
      `,
    },
    {
      pname: 'STENCIL_BACK_PASS_DEPTH_PASS',
      value: 'KEEP',
      help: `
      operation when depth test passes for back facing triangles.
      One of: ${stencilOps}

${stencilOpSnippet('back')}
      `,
    },
    {
      pname: 'STENCIL_BACK_REF',
      value: '0',
      help: `
      reference value to use for stencil test for back facing triangles.

${stencilFuncSnippet('back')}
      `,
    },
    {
      pname: 'STENCIL_BACK_VALUE_MASK',
      value: '0xFF',
      help: `
      mask value to use for stencil test for back facing triangles.

${stencilFuncSnippet('back')}
      `,
    },
    {
      pname: 'STENCIL_BACK_WRITEMASK',
      value: '0xFF',
      help: stencilWriteMaskSnippet('front'),
    },
];

const blendFuncs = helpToMarkdown(`
--ZERO--,
--ONE--,
--SRC_COLOR--,
--ONE_MINUS_SRC_COLOR--,
--DST_COLOR--,
--ONE_MINUS_DST_COLOR--,
--SRC_ALPHA--,
--ONE_MINUS_SRC_ALPHA--,
--DST_ALPHA--,
--ONE_MINUS_DST_ALPHA--,
--CONSTANT_COLOR--,
--ONE_MINUS_CONSTANT_COLOR--,
--CONSTANT_ALPHA--,
--ONE_MINUS_CONSTANT_ALPHA--,
--SRC_ALPHA_SATURATE--
`);

const blendFuncSnippet = `
---js
// set both RGB and alpha to same value
const srcRGBFunc = gl.ONE;
const dstRGBFunc = gl.ONE_MINUS_SRC_ALPHA;
gl.blendFunc(srcRGBFunc, dstRGBFunc);

// set RGB and alpha to separate values
const srcAlphaFunc = gl.ONE;
const dstAlphaFunc = gl.ONE;
gl.blendFuncSeparate(
    srcRGBFunc, dstRGBFunc, srcAlphaFunc, dstAlphaFunc);
---
`;

const blendEquationSnippet = `
One of --FUNC_ADD--, --FUNC_SUBTRACT--, --FUNC_REVERSE_SUBTRACT--

---js
// set both RGB and ALPHA equations to the same value
const rgbEquation = gl.FUNC_ADD;
gl.blendEquation(rgbEquation);

// set RGB and alpha equations to separate values
const alphaEquation = gl.FUNC_SUBTRACT;
gl.blendEquationSeparate(rgbEquation, alphaEquation);
---
`;

const blendState = [
    {
      pname: 'BLEND',
      value: 'false',
      help: `
      blending enabled/disabled

      ---js
      gl.enable(gl.BLEND);
      gl.disable(gl.BLEND);
      ---
      `,
    },
    {
      pname: 'BLEND_DST_RGB',
      value: 'ZERO',
      help: `
      The blend function for destination RGB.
      One of ${blendFuncs}.

${blendFuncSnippet}
      `,
    },
    {
      pname: 'BLEND_SRC_RGB',
      value: 'ONE',
      help: `
      The blend function for source RGB.
      One of ${blendFuncs}.

${blendFuncSnippet}
      `,
    },
    {
      pname: 'BLEND_DST_ALPHA',
      value: 'ZERO',
      help: `
      The blend function for destination alpha
      One of ${blendFuncs}.

${blendFuncSnippet}
      `,
    },
    {
      pname: 'BLEND_SRC_ALPHA',
      value: 'ONE',
      help: `
      The blend function for source alpha
      One of ${blendFuncs}.

${blendFuncSnippet}
      `,
    },
    {
      pname: 'BLEND_COLOR',
      value: '0, 0, 0, 0',
      help: `
      constant color and alpha used when blend function
      is --gl.CONSTANT_COLOR--, --gl.CONSTANT_ALPHA--,
      --gl.ONE_MINUS_CONSTANT_COLOR--, or --gl.ONE_MINUS_CONSTANT_ALPHA--.

      ---js
      gl.blendColor(r, g, b, a);
      ---
      `,
    },
    {
      pname: 'BLEND_EQUATION_RGB',
      value: 'FUNC_ADD',
      help: `
      Blend equation for RGB.

${blendEquationSnippet}
      `,
    },
    {
      pname: 'BLEND_EQUATION_ALPHA',
      value: 'FUNC_ADD',
      help: `
      Blend equation for alpha  .

${blendEquationSnippet}
      `,
    },
];

const polygonState = [
    {
      pname: 'CULL_FACE',
      value: 'false',
      help: `
      Whether or not to cull triangles based on which way they are facing.

      ---js
      // enable
      gl.enable(gl.CULL_FACE);

      // disable
      gl.disable(gl.CULL_FACE);
      ---
      `,
    },
    {
      pname: 'CULL_FACE_MODE',
      value: 'BACK',
      help: `
      Which faces are culled when culling is on. Valid values are
      --FRONT--, --BACK--, --FRONT_AND_BACK--. 

      ---js
      gl.cullFace(gl.FRONT);
      ---
      `,
    },
    {
      pname: 'FRONT_FACE',
      value: 'CCW',
      help: `
      Which faces are considered front facing. Valid values are
      --CW--, --CCW--. 

      ---js
      gl.frontFace(gl.CW);
      ---
      `,
    },
    {
      pname: 'POLYGON_OFFSET_UNITS',
      value: '0',
      help: `The amount to offset the calculated depth value for the depth test.

      ---js
      const factor = 0;
      const units = 1;
      gl.polygonOffset(factor, units);
      ---
      `,
    },
    {
      pname: 'POLYGON_OFFSET_FACTOR',
      value: '0',
      help: `The depth factor to offset the calculated depth value for the depth test.

      ---js
      const factor = 1;
      const units = 0;
      gl.polygonOffset(factor, units);
      ---
      `,
    },
];

const clearState = [
    {
      pname: 'COLOR_CLEAR_VALUE',
      value: '0, 0, 0, 0',
      help: `
      Value to clear the color buffer to when calling --gl.clear--
      with the --gl.COLOR_BUFFER_BIT-- set

      Be aware by default a canvas is composited with the webpage
      using premultiplied alpha.

      ---js
      const r = 1;
      const g = 0.5;
      const b = 0.3;
      const a = 1;
      gl.clearColor(r, g, b, a);
      ---
      `,
    },
    {
      pname: 'DEPTH_CLEAR_VALUE',
      value: '1',
      help: `
      the value to clear the depth buffer to when calling --gl.clear--
      with the --gl.DEPTH_BUFFER_BIT-- set

      ---js
      gl.clearDepth(value);
      ---
      `,
    },
    {
      pname: 'STENCIL_CLEAR_VALUE',
      value: '0xFF',
      help: `
      the value to clear the depth buffer to when calling --gl.clear--
      with the --gl.STENCIL_BUFFER_BIT-- set

      ---js
      gl.clearStencil(0xFF);
      ---
      `,
    },
];

const miscState = [
    {
      pname: 'COLOR_WRITEMASK',
      value: 'true, true, true, true',
      help: `
      sets which channels can be written to. Set with

      ---js
      const red = true;
      const green = true;
      const blue = true;
      const alpha = true;
      gl.colorMask(red, green, blue, alpha);
      ---
      `,
    },
    {
      pname: 'VIEWPORT',
      value: '0, 0, 300, 150',
      help: `
      How to convert from clip space to pixel space.

      ---js
      const x = 0;
      const y = 0;
      const width = gl.canvas.width;
      const height = gl.canvas.height;
      gl.viewport(x, y, width, height);
      ---
      `,
    },
    {
      pname: 'SCISSOR_TEST',
      value: 'false',
      help: `
      Whether the scissor test is enabled

      ---js
      // enable
      gl.enable(gl.SCISSOR_TEST);

      // disable
      gl.disable(gl.SCISSOR_TEST);
      ---
      `,
    },
    {
      pname: 'SCISSOR_BOX',
      value: '0, 0, 0, 0',
      help: `
      The dimensions of the scissor test. If the the scissor test is enabled
      then WebGL will not rendered pixels outside the scissor box.

      ---js
      const x = 50;
      const y = 60;
      const width = 70;
      const height = 80;
      gl.scissor(x, y, width, height);
      ---
      `,
    },
    {
      pname: 'UNPACK_ALIGNMENT',
      value: '4',
      help: `
      Used by --texImage-- functions. Each row of data
      must be aligned by this number of bytes and a multiple of this
      number of bytes. Valid values are --1--, --2--, --4--, and --8--.
      Default: --4--

      ---js
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      ---
      `,
    },
    {
      pname: 'PACK_ALIGNMENT',
      value: '4',
      help: `
      Used by --readPixels-- function. Each row of data
      must be aligned by this number of bytes and a multiple of this
      number of bytes. Valid values are --1--, --2--, --4--, and --8--.
      Default: --4--

      ---js
      gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
      ---
      `,
    },
];

function createTextureDisplay(parent, imgHref) {
  const texElem = createTemplate(parent, '#texture-template');

  const activeTexNote = helpToMarkdown(`
    note: the texture affected is the current active texture on
    the specified bind point. ie (--webglState.textureUnits[activeTexture][bindPoint]--)
  `);

  const mipsExpander = createExpander(texElem, 'mips');
  const mipsOuterElem = addElem('div', mipsExpander);
  const mipsElem = addElem('div', mipsOuterElem, {className: 'mips'});
  const numMips = 8;
  for (let i = 0; i < numMips; ++i) {
    const size = 2 ** (numMips - i - 1);
    addElem('div', mipsElem, {
      className: `mip${i}`,
      style: { backgroundImage: `url(${imgHref})` },
      dataset: {
        help: helpToMarkdown(`
          Uploading data

          ---js
          const target = gl.TEXTURE_2D;
          const level = ${i};
          const internalFormat = gl.RGBA;
          const width = ${size};
          const height = ${size};
          const format = gl.RGBA;
          const type = gl.UNSIGNED_BYTE;
          gl.texImage2D(
              target, level, internalFormat,
              width, height, 0, format, type,
              someUnit8ArrayWith${size}x${size}x4Values);
          ---

          Uploading an image/canvas/video. The image must
          have finished downloading.

          ---js
          const target = gl.TEXTURE_2D;
          const level = ${i};
          const internalFormat = gl.RGBA;
          const format = gl.RGBA;
          const type = gl.UNSIGNED_BYTE;
          gl.texImage2D(
              target, level, internalFormat,
              format, type, imageCanvasVideoElem);
          ---

          mips > 0 can be generated by calling
          --gl.genererateMipmap(gl.TEXTURE_2D);--

          ${activeTexNote}`),
      },
    });
  }

  const texState = [
   {
      pname: 'WRAP_S',
      value: 'REPEAT',
      help: `
      what happens for texture coordinates outside the 0 to 1 range
      in the S direction (horizontal). Can be one of --gl.REPEAT--,
      --gl.CLAMP_TO_EDGE--, --gl.MIRRORED_REPEAT--. **For non power
      of 2 textures must be --gl.CLAMP_TO_EDGE--**.

      ---js
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      ---

      ${activeTexNote}`,
    },
    {
      pname: 'WRAP_T',
      value: 'REPEAT',
      help: `
      what happens for texture coordinates outside the 0 to 1 range
      in the S direction (vertical). Can be one of --gl.REPEAT--,
      --gl.CLAMP_TO_EDGE--, --gl.MIRRORED_REPEAT--. **For non power
      of 2 textures must be --gl.CLAMP_TO_EDGE--**.

      ---js
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      ---

      ${activeTexNote}`,
    },
    {
      pname: 'MIN_FILTER',
      value: 'LINEAR_MIPMAP_NEAREST',
      help: `
      How the texture is sampled when drawn smaller than its intrinsic size.
      Can be one of:
      --gl.NEAREST--,
      --gl.LINEAR--,
      --gl.NEAREST_MIPMAP_NEAREST--,
      --gl.LINEAR_MIPMAP_NEAREST--,
      --gl.NEAREST_MIPMAP_LINEAR--,
      --gl.LINEAR_MIPMAP_LINEAR--.
      **For non power of 2 textures must be --gl.NEAREST-- or --gl.LINEAR--**.

      ---js
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      ---

      ${activeTexNote}`,
    },
    {
      pname: 'MAG_FILTER',
      value: 'LINEAR',
      help: `
      How the texture is sampled when drawn larger than its intrinsic size.
      Can be one of
      --gl.NEAREST--,
      --gl.LINEAR--.

      ---js
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      ---

      ${activeTexNote}`,
    },
  ];

  createStateTable(texState, texElem, 'texture state');
  makeDraggable(texElem);
  return texElem;
}

function createTextureUnits(parent, maxUnits = 8) {
  const expander = createExpander(parent, 'Texture Units');
  const tbody = createTable(expander, ['2D', 'CUBE_MAP']);
  for (let i = 0; i < maxUnits; ++i) {
    const tr = addElem('tr', tbody);
    addElem('td', tr, {
      textContent: 'null',
      dataset: {
        help: helpToMarkdown(`
          bind a texture to this unit with

          ---js
          gl.activeTexture(gl.TEXTURE0 + ${i});
          gl.bindTexture(gl.TEXTURE_2D, someTexture);
          ---
        `),
      },
    });
    addElem('td', tr, {
      textContent: 'null',
      dataset: {
        help: helpToMarkdown(`
          bind a texture to this unit with

          ---js
          gl.activeTexture(gl.TEXTURE0 + ${i});
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, someTexture);
          ---
        `),
      },
    });
  }
  return expander;
}

function expand(elem) {
  if (elem.classList.contains('expander')) {
    elem.classList.add('open');
  } else {
    elem.querySelector('.expander').classList.add('open');
  }
}

const diagramElem = document.querySelector('#diagram');
const codeElem = document.querySelector('#code');

const globalState = document.querySelector('#global-state');
expand(createTextureUnits(globalState, 8));
expand(createStateTable(clearState, globalState, 'clear state'));
expand(createStateTable(depthState, globalState, 'depth state'));
createStateTable(blendState, globalState, 'blend state');
createStateTable(miscState, globalState, 'misc state');
createStateTable(stencilState, globalState, 'stencil state');
createStateTable(polygonState, globalState, 'polygon state');
makeDraggable(globalState, 10, 10);
makeDraggable(document.querySelector('canvas'));


const js = document.querySelector('#js').text;
const lines = [...js.matchAll(/[^`;]*(?:`[^`]*?`)?[^`;]*;?;\n/g)].map(m => m[0]);
for (const line of lines) {
  eval(line.replace(/const |let /g, ''));
  const pre = document.createElement('pre');
  pre.textContent = line;
  codeElem.appendChild(pre);
}

function createShader(gl, type, glslString) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, glslString);
  gl.compileShader(shader);
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === 0) {
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

function createProgram(gl, vsGLSL, fsGLSL) {
  const program = gl.createProgram();
  gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsGLSL));
  gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsGLSL));
  gl.linkProgram(program);
  if (gl.getProgramParameter(program, gl.LINK_STATUS) === 0) {
    throw new Error(gl.getProgramInfoLog(program));
  }
  return program;
}

const tx = createTextureDisplay(diagramElem, '/webgl/resources/f-texture.png');

createVertexArrayDisplay(diagramElem, [
  {size: 2, type: 'FLOAT', buffer: 'texcoordBuffer',},
  {size: 3, type: 'FLOAT', buffer: 'normalBuffer',},
  {size: 3, type: 'FLOAT', buffer: 'positionBuffer',},
]);

createProgramDisplay(diagramElem, gl, prg);

var divA       = globalState;
var divB       = tx;
var arrowLeft  = document.querySelector("#arrowLeft");
var arrowRight = document.querySelector("#arrowRight");

function getPageRelativePos(elem) {
  const rect = elem.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX | 0,
    top: rect.top + window.scrollY | 0,
    width: rect.width,
    height: rect.height,
  };
}
var drawConnector = function() {
  const divAPos = getPageRelativePos(divA);
  const divBPos = getPageRelativePos(divB);
  var posnALeft = {
    x: divAPos.left - 8,
    y: divAPos.top  + divAPos.height / 2,
  };
  var posnARight = {
    x: divAPos.left + divAPos.width + 8,
    y: divAPos.top  + divAPos.height / 2    
  };
  var posnBLeft = {
    x: divBPos.left - 8,
    y: divBPos.top  + divBPos.height / 2
  };
  var posnBRight = {
    x: divBPos.left + divBPos.width + 8,
    y: divBPos.top  + divBPos.height / 2
  };
  var dStrLeft =
      "M" +
      (posnALeft.x      ) + "," + (posnALeft.y) + " " +
      "C" +
      (posnALeft.x - 100) + "," + (posnALeft.y) + " " +
      (posnBLeft.x - 100) + "," + (posnBLeft.y) + " " +
      (posnBLeft.x      ) + "," + (posnBLeft.y);
  arrowLeft.setAttribute("d", dStrLeft);
  var dStrRight =
      "M" +
      (posnBRight.x      ) + "," + (posnBRight.y) + " " +
      "C" +
      (posnBRight.x + 100) + "," + (posnBRight.y) + " " +
      (posnARight.x + 100) + "," + (posnARight.y) + " " +
      (posnARight.x      ) + "," + (posnARight.y);
  arrowRight.setAttribute("d", dStrRight);
};

drawConnector();


</script>